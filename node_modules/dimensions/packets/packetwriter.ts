import DumbPacketWriter from "dimensions/packets/dumbpacketwriter";
import { getPackedStringByteLen } from "dimensions/utils";
import NetworkText from "dimensions/packets/networktext";
import Color from "dimensions/color";

interface QueueItem {
    method: string;
    value: any;
}

class PacketWriter {
    private _queue: QueueItem[] = [];
    private _size: number = 3;
    private _data: Buffer | null = null;

    private compile() {
        const writer = new DumbPacketWriter(this._size);
        for (const item of this._queue) {
            writer[item.method](item.value);
        }
        
        this._data = writer.buf;
    }

    public setType(type: number) {
        this._queue.push({method: "setType", value: type});
        return this;
    }

    public packInt16(int16: number) {
        this._queue.push({method: "packInt16", value: int16});
        this._size += 2;
        return this;
    }

    public packUInt16(uint16: number) {
        this._queue.push({method: "packUInt16", value: uint16});
        this._size += 2;
        return this;
    }

    public packInt32(int32: number) {
        this._queue.push({method: "packInt32", value: int32});
        this._size += 4;
        return this;
    }

    public packUInt32(uint32: number) {
        this._queue.push({method: "packUInt32", value: uint32});
        this._size += 4;
        return this;
    }

    public packSingle(single: number) {
        this._queue.push({method: "packSingle", value: single});
        this._size += 4;
        return this;
    }

    public packByte(byte: number) {
        this._queue.push({method: "packByte", value: byte});
        this._size += 1;
        return this;
    }

    public packHex(hex: string) {
        if (hex.length % 2 !== 0) {
            throw new Error("Tried to pack invalid hex string.");
        }

        this._queue.push({method: "packHex", value: hex});
        this._size += hex.length / 2;
        return this;
    }

    public packString(str: string) {
        this._queue.push({method: "packString", value: str});
        this._size += getPackedStringByteLen(str);
        return this;
    }

    public packNetworkText(networkText: NetworkText) {
        this.packByte(networkText.mode);
        this.packString(networkText.text);
        return this;
    }

    public packColor(color: Color) {
        this.packByte(color.R);
        this.packByte(color.G);
        this.packByte(color.B);
        return this;
    }
    
    public get buf() {
        if (this._data === null) {
            this.compile();
        }

        return this._data as Buffer;
    }

    public get data() {
        if (this._data === null) {
            this.compile();
        }

        return (this._data as Buffer).slice(0, this._size);
    }
}

export default PacketWriter;
