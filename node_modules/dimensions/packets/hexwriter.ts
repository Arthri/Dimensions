import Color from 'dimensions/color';
import { a2hex, getCorrectHex } from 'dimensions/utils';
import * as utf8 from 'utf8';

class HexWriter {
    protected _data: string;

    constructor() {
        this._data = "";
    }

    public packString(str: string): HexWriter {
        let strHex: string = a2hex(utf8.encode(str));
        let sizeOfString: number = strHex.length / 2;
        let strLengthInHex: string;

        /* Sizes >= 128 require an extra byte (and maybe more but I doubt
            we will get bigger than strings of length 255*128) */
        if (sizeOfString >= 128) {
            strLengthInHex = getCorrectHex(((sizeOfString % 128) + 128).toString(16)) + getCorrectHex(Math.floor(sizeOfString / 128).toString(16));
        } else {
            strLengthInHex = getCorrectHex((strHex.length / 2).toString(16));
        }

        this._data += strLengthInHex + strHex;
        return this;
    }

    public packHex(hex: string): HexWriter {
        this._data += hex;
        return this;
    }

    public packByte(byte: number): HexWriter {
        if (byte < 0) {
            byte = -byte;
        }

        if (byte > 255) {
            byte = 0;
        }

        // 2 hex digits
        let intHex: string = (byte).toString(16);
        if (intHex.length !== 2) {
            for (let j: number = intHex.length; j < 2; j++) {
                intHex = "0" + intHex;
            }
        }

        this._data += intHex;
        return this;
    }

    public packColor(color: Color): HexWriter {
        this.packByte(color.R);
        this.packByte(color.G);
        this.packByte(color.B);
        return this;
    }

    public packInt16(int16: number): HexWriter {
        // Gets rid of first 16 bits of the 32 bit input number
        if (int16 < 0) {
            int16 = (int16 << 16) >>> 16;
            int16 |= 32768;
        }

        // 4 hex digits
        var intHex = (int16).toString(16);
        if (intHex.length !== 4) {
            for (let j: number = intHex.length; j < 4; j++) {
                intHex = "0" + intHex;
            }
        }


        // Reverse byte order
        let firstByte: string = intHex.substr(0, 2);
        var secondByte: string = intHex.substr(2, 2);
        intHex = secondByte + firstByte;
        this._data += intHex;
        return this;
    }

    public packInt32(int32: number): HexWriter {
        if (int32 < 0) {
            int32 = (int32 << 32) >>> 32;
            int32 |= 2147483648;
            int32 = int32 >>> 0;
        }

        let intHex: string = (int32).toString(16);
        if (intHex.length !== 8) {
            for (let j: number = intHex.length; j < 8; j++) {
                intHex = "0" + intHex;
            }
        }


        // Reverse byte order
        let firstByte: string = intHex.substr(0, 2);
        let secondByte: string = intHex.substr(2, 2);
        let thirdByte: string = intHex.substr(4, 2);
        let fourthByte: string = intHex.substr(6, 2);
        intHex = fourthByte + thirdByte + secondByte + firstByte;
        this._data += intHex;
        return this;
    }

    public packSingle(float: number): HexWriter {
        let tempBuffer: Buffer = new Buffer(4);
        tempBuffer.writeFloatLE(float, 0);
        let single: string = tempBuffer.toString('hex');
        this._data += single;
        return this;
    }

    public get data(): string {
        return this._data;
    }
}

export default HexWriter;