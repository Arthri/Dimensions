import PacketWriter from 'dimensions/packets/packetwriter';
import PacketReader from 'dimensions/packets/packetreader';

enum Mode
{
    Literal,
    Formattable,
    LocalizationKey,
}

class NetworkText
  {
    public static FromLiteral(text: string): NetworkText
    {
      return new NetworkText(text, Mode.Literal);
    }

    public static readonly Empty: NetworkText = NetworkText.FromLiteral("");
    private _substitutions: NetworkText[];
    private _text: string;
    private _mode: Mode;

    constructor(text: string, mode: Mode)
    {
      this._text = text;
      this._mode = mode;
    }

    /*private static ConvertSubstitutionsToNetworkText(substitutions: object[]): NetworkText[]
    {
      let networkTextArray: NetworkText[] = [];
      for (let index = 0; index < substitutions.length; ++index)
      {
        networkText: NetworkText = substitutions[index] as NetworkText ?? NetworkText.FromLiteral(substitutions[index].ToString());
        networkTextArray[index] = networkText;
      }
      return networkTextArray;
    }*/

    /*public static FromFormattable(string text, params object[] substitutions): NetworkText
    {
      return new NetworkText(text, NetworkText.Mode.Formattable)
      {
        _substitutions = NetworkText.ConvertSubstitutionsToNetworkText(substitutions)
      };
    }*/

    /*public static FromKey(key: string, params object[] substitutions): NetworkText
    {
      return new NetworkText(key, NetworkText.Mode.LocalizationKey)
      {
        _substitutions = NetworkText.ConvertSubstitutionsToNetworkText(substitutions)
      };
    }

    public GetMaxSerializedSize(): number
    {
      int num = 0 + 1 + (4 + Encoding.UTF8.GetByteCount(this._text));
      if (this._mode != NetworkText.Mode.Literal)
      {
        ++num;
        for (int index = 0; index < this._substitutions.Length; ++index)
          num += this._substitutions[index].GetMaxSerializedSize();
      }
      return num;
    }*/

    public Serialize(writer: PacketWriter): void
    {
      writer.packByte(this._mode);
      writer.packString(this._text);
      this.SerializeSubstitutionList(writer);
    }

    private SerializeSubstitutionList(writer: PacketWriter): void
    {
      if (this._mode == Mode.Literal)
        return;

      writer.packByte(this._substitutions.length);
      for (let index = 0; index < (this._substitutions.length & 255); ++index)
        this._substitutions[index].Serialize(writer);
    }

    public static Deserialize(reader: PacketReader): NetworkText
    {
      let mode: Mode = <Mode> reader.readByte();
      let networkText = new NetworkText(reader.readString(), mode);
      networkText.DeserializeSubstitutionList(reader);
      return networkText;
    }

    public static DeserializeLiteral(reader: PacketReader): NetworkText
    {
      let mode = <Mode> reader.readByte();
      let networkText = new NetworkText(reader.readString(), mode);
      networkText.DeserializeSubstitutionList(reader);
      if (mode != Mode.Literal)
        networkText.SetToEmptyLiteral();
      return networkText;
    }

    private DeserializeSubstitutionList(reader: PacketReader): void
    {
      if (this._mode == Mode.Literal)
        return;

      this._substitutions = [];
      let length = reader.readByte();
      for (let index = 0; index < length; ++index)
        this._substitutions[index] = NetworkText.Deserialize(reader);
    }

    private SetToEmptyLiteral(): void
    {
      this._mode = Mode.Literal;
      this._text = "";
      this._substitutions = [];
    }

    public ToString(): string
    {
      try
      {
        switch (this._mode)
        {
          case Mode.Literal:
            return this._text;
          case Mode.Formattable:
            return "[Formattable]";
          case Mode.LocalizationKey:
            return "[LocalizationKey]";
          default:
            return this._text;
        }
      }
      catch (ex)
      {
        this.SetToEmptyLiteral();
      }

      return this._text;
    }
  }

  export default NetworkText;