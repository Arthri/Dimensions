import * as path from 'path';
import Packet from 'dimensions/packet';
import BufferReader from 'dimensions/packets/bufferreader';
import * as utf8 from 'utf8';
import PacketWriter from './packets/packetwriter';
import BufferWriter from './packets/bufferwriter';

export interface BuffersPackets {
  bufferPacket: Buffer;
  packets: Packet[];
}

export function bufferToText(buf: Buffer): string {
    const reader = new BufferReader(buf);
    let str: string = '';
    for (let i: number = 0; i < buf.length; i++) {
      str += String.fromCharCode(reader.readByte());
    }
    return str;
  }

export function textToBuffer(str: string): Buffer {
  const writer = new PacketWriter(BufferWriter);
  for (var i = 0, l = str.length; i < l; i++) {
    writer.packByte(str.charCodeAt(i));
  }

  return writer.data;
}

export function getProperIP(ip: string): string {
  let IPFromRequest: string = ip;
  let indexOfColon: number = IPFromRequest.lastIndexOf(':');
  let IP: string = IPFromRequest.substring(indexOfColon + 1, IPFromRequest.length);
  return IP;
}

export function getPacketLengthFromData(hexStr: string): string {
  let prePacketLength: string = (hexStr.length / 2).toString(16);
  if (prePacketLength.length !== 4) {
    for (let j: number = prePacketLength.length; j < 4; j++) {
      prePacketLength = "0" + prePacketLength;
    }
  }

  // Assign hex packet length
  let packetLength: string = (prePacketLength.length / 2 + parseInt(prePacketLength, 16)).toString(16);

  // Ensure it takes up 4 hex digits
  if (packetLength.length !== 4) {
    for (let j: number = packetLength.length; j < 4; j++) {
      packetLength = "0" + packetLength;
    }
  }

  // Reverse byte order
  let firstByte: string = packetLength.substr(0, 2);
  let secondByte: string = packetLength.substr(2, 2);
  packetLength = secondByte + firstByte + packetLength.substr(4);

  return packetLength;
}

export function getPacketTypeFromBuffer(buf: Buffer): number {
  return buf.readUInt8(2);
}

export function getPacketsFromBuffer(buf: Buffer): BuffersPackets {
  const reader = new BufferReader(buf);
  let packets: Packet[] = [];
  let end: boolean = false;
  let length: number;
  let data: Buffer;
  let index: number = 0;
  let packetType: number;
  let bufferPacket: Buffer = new Buffer("");
  while (!end) {
    length = reader.readUInt16();

    if (length === 0) {
      end = true;
    } else {
      data = buf.slice(reader.head - 2, reader.head - 2 + length);
      reader.head += length - 2;
      if (reader.head > buf.length) {
        bufferPacket = data;
        end = true;
      } else {
        packetType = getPacketTypeFromBuffer(data);
        packets.push({
          packetType: packetType,
          data: data
        });

        if (reader.head === buf.length) {
          end = true;
        }
      }
    }
  }

  return { bufferPacket: bufferPacket, packets: packets };
}

export function _invalidateRequireCacheForFile(filePath: string, require: NodeRequire) {
  var realPath = path.resolve(filePath);
  delete require.cache[realPath];
}

export function requireNoCache(filePath: string, require) {
  _invalidateRequireCacheForFile(filePath, require);
  return require(filePath);
}

export function getPackedStringByteLen(str: string) {
  const strLen = textToBuffer(utf8.encode(str)).length;
  if (str.length > 128) {
    return 2 + strLen;
  }

  return 1 + strLen;
}