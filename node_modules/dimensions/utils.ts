import * as path from 'path';
import * as util from 'util';
import Color from 'dimensions/color';
import Packet from 'dimensions/packet';

export interface BuffersPackets {
  bufferPacket: string;
  packets: Packet[];
}

export function hex2a(hexx: string): string {
  let hex: string = hexx.toString(); //force conversion
  let str: string = '';
  for (let i: number = 0; i < hex.length; i += 2)
    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  return str;
}

export function a2hex(str: string): string {
  let arr: string[] = [];
  for (var i = 0, l = str.length; i < l; i++) {
    let prehex: string = Number(str.charCodeAt(i)).toString(16);
    let hex: string = prehex.length === 1 ? `0${prehex}` : prehex;
    arr.push(hex);
  }

  let builtString: string = arr.join('');

  // Must have even number of hex digits
  if (builtString.length % 2 !== 0) {
    builtString = "0" + builtString;
  }
  return builtString;
}

export function str2Hex(str: string): Buffer {
  return new Buffer(str, 'hex');
}

export function hex2str(hex: Buffer): string {
  return hex.toString("hex");
}

export function getProperIP(ip: string): string {
  let IPFromRequest: string = ip;
  let indexOfColon: number = IPFromRequest.lastIndexOf(':');
  let IP: string = IPFromRequest.substring(indexOfColon + 1, IPFromRequest.length);
  return IP;
}

export function getPacketLengthFromData(hexStr: string): string {
  let prePacketLength: string = (hexStr.length / 2).toString(16);
  if (prePacketLength.length !== 4) {
    for (let j: number = prePacketLength.length; j < 4; j++) {
      prePacketLength = "0" + prePacketLength;
    }
  }

  // Assign hex packet length
  let packetLength: string = (prePacketLength.length / 2 + parseInt(prePacketLength, 16)).toString(16);

  // Ensure it takes up 4 hex digits
  if (packetLength.length !== 4) {
    for (let j: number = packetLength.length; j < 4; j++) {
      packetLength = "0" + packetLength;
    }
  }

  // Reverse byte order
  let firstByte: string = packetLength.substr(0, 2);
  let secondByte: string = packetLength.substr(2, 2);
  packetLength = secondByte + firstByte + packetLength.substr(4);

  return packetLength;
}

export function getPacketTypeFromHexString(str: string): number {
  // Index 4, Length 2, Base 16
  return parseInt(str.substr(4, 2), 16);
}

export function getPacketsFromHexString(str: string): BuffersPackets {
  let packets: Packet[] = [];
  let end: boolean = false;
  let length: number;
  let data: string;
  let index: number = 0;
  let packetType: number;
  let bufferPacket: string = "";
  while (!end) {
    if (str.substr(index).length > 0) {
      //console.log(str.substr(index)+" - "+str.substr(index).length);
      // Length is *2 because we are parsing individual characters,
      // instead of individual bytes
      length = parseInt(str.substr(index + 2, 2) + str.substr(index, 2), 16) * 2;

      if (length === 0) {
        end = true;
      } else {
        data = str.substr(index, length);
        index += length;
        if (index > str.length) {
          //console.log("Index [" + index + "] exceeds data length [" + str.length + "]");
          bufferPacket = data;
        } else {
          packetType = getPacketTypeFromHexString(data);
          packets.push({
            packetType: packetType,
            data: data
          });
        }
      }
    } else {
      end = true;
    }
  }

  return { bufferPacket: bufferPacket, packets: packets };
}

/* Ensures a hex string is an even number of hex digits */
export function getCorrectHex(hexString: string): string {
    if (hexString.length % 2 !== 0) {
      hexString = "0" + hexString;
    }

    return hexString;
}

export function _invalidateRequireCacheForFile(filePath: string, require: NodeRequire) {
  var realPath = path.resolve(filePath);
  delete require.cache[realPath];
}

export function requireNoCache(filePath: string, require) {
  _invalidateRequireCacheForFile(filePath, require);
  return require(filePath);
}

let MathEx = {
  getRandomInt: function (min, max) {
    return Math.floor(Math.random() * ((max + 1) - min)) + min;
  }
}
