import RoutingServer from 'dimensions/routingserver';
import * as Language from 'dimensions/language';
import assert = require('node:assert');

export interface ConfigListenServer {
  listenPort: number;
  routingServers: RoutingServer[];
}

export interface ConfigNoListenServer {
  routingServers: RoutingServer[];
}

export interface LogOptions {
  clientTimeouts: boolean;
  clientConnect: boolean;
  clientDisconnect: boolean;
  clientError: boolean;
  tServerConnect: boolean;
  tServerDisconnect: boolean;
  tServerError: boolean;
  clientBlocked: boolean;
  extensionLoad: boolean;
  outputToConsole: boolean;
  extensionError: boolean;
}

export interface FakeVersion {
  enabled: boolean;
  terrariaVersion: number;
}

export interface BlackList {
  enabled: boolean;
  apiKey: string;
}

export interface RestApiResponse {
  name?: string;
  worldName?: string;
  terrariaServerPort?: number;
  hasServerPassword?: boolean;
  maxPlayers?: number;
  version?: string;
}

export interface RestApi {
  enabled: boolean;
  port: number;
  response?: RestApiResponse;
}

export interface ConnectionLimit {
  enabled: boolean;
  connectionLimitPerIP: number;
  kickReason: string;
}

export interface ConnectionRateLimit {
  enabled: boolean;
  connectionRateLimitPerIP: number;
}

export interface RedisConfig {
  enabled: boolean;
  host: string;
  port: number;
}

export interface NameChanges {
  mode: "legacy" | "rewrite";
  exclusions: string[];
}

export interface UnvalidatedConfigOptions {
  socketTimeout: number;
  socketNoDelay: boolean;
  fakeVersion: FakeVersion;
  restApi: RestApi;
  blockInvis: boolean;
  blacklist: BlackList;
  log: LogOptions;
  connectionLimit: ConnectionLimit;
  connectionRateLimit: ConnectionRateLimit;
  redis: RedisConfig;
  nameChanges?: NameChanges;
  language?: string,
  languageOverrides?: Language.LanguagePhrasesOverrides
}

export interface ConfigOptions {
  socketTimeout: number;
  socketNoDelay: boolean;
  fakeVersion: FakeVersion;
  restApi: RestApi;
  blockInvis: boolean | { enabled: boolean, servers: string[] };
  blacklist: BlackList;
  log: LogOptions;
  connectionLimit: ConnectionLimit;
  connectionRateLimit: ConnectionRateLimit;
  redis: RedisConfig;
  nameChanges?: NameChanges;
  language: Language.LanguageDefinition,
}

export interface UnvalidatedConfig {
  servers: (ConfigListenServer | ConfigNoListenServer)[];
  options: UnvalidatedConfigOptions;
}

export interface Config {
  servers: (ConfigListenServer | ConfigNoListenServer)[];
  options: ConfigOptions;
}

const unvalidatedConfig: UnvalidatedConfig = require(`../../../config.js`).ConfigSettings;
let validatedConfig: Config = {
  servers: unvalidatedConfig.servers,
  options: {
    ...unvalidatedConfig.options,
    language: Language.english,
  },
};

try {
  if (typeof unvalidatedConfig.options.nameChanges !== "undefined") {
    assert(unvalidatedConfig.options.nameChanges.mode === "legacy" || unvalidatedConfig.options.nameChanges.mode === "rewrite", "nameChanges.mode must be either 'legacy' or 'rewrite'");
    assert(Array.isArray(unvalidatedConfig.options.nameChanges.exclusions), "nameChanges.exclusions must be an array");
  }

  if (typeof unvalidatedConfig.options.language !== "undefined") {
    switch (unvalidatedConfig.options.language.toLowerCase()) {
      case Language.english.isoCode.toLowerCase():
      case Language.english.name.toLowerCase():
      case Language.english.englishName.toLowerCase():
        break;
      case Language.chinese.isoCode.toLowerCase():
      case Language.chinese.name.toLowerCase():
      case Language.chinese.englishName.toLowerCase():
        validatedConfig.options.language = Language.chinese;
        break;
      default:
        console.log("Unrecognised language:", unvalidatedConfig.options.language);
        process.exit(1);
    }
  }

  if (typeof unvalidatedConfig.options.languageOverrides !== "undefined") {
    validatedConfig.options.language.phrases = {
      ...validatedConfig.options.language.phrases,
      ...unvalidatedConfig.options.languageOverrides,
    };
  }

} catch (e) {
  console.log("Error validating config:");
  throw e
}
export const ConfigSettings: Config = validatedConfig;
