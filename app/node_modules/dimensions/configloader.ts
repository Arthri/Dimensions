import RoutingServer from 'dimensions/routingserver';
import * as Language from 'dimensions/language';
import assert = require('assert');

export interface ConfigListenServer {
  listenPort: number;
  routingServers: RoutingServer[];
}

export interface ConfigNoListenServer {
  routingServers: RoutingServer[];
}

export interface LogOptions {
  clientTimeouts: boolean;
  clientConnect: boolean;
  clientDisconnect: boolean;
  clientError: boolean;
  checkingClientConnect: boolean;
  checkingClientDisconnect: boolean;
  checkingClientError: boolean;
  checkingClientTimeouts: boolean;
  tServerConnect: boolean;
  tServerDisconnect: boolean;
  tServerError: boolean;
  clientBlocked: boolean;
  extensionLoad: boolean;
  outputToFile: boolean;
  outputToConsole: boolean;
  extensionError: boolean;
  format?: {
    console?: "JSON" | "PlainText";
    file?: "JSON" | "PlainText";
  };
}

export interface FakeVersion {
  enabled: boolean;
  terrariaVersion: number;
}

export interface UnvalidatedBlackList {
  enabled?: boolean;
  hostname?: string;
  path?: string;
  port?: number;
  apiKey?: string;
  errorPolicy?: "AllowJoining" | "DenyJoining";
}

export type EnabledBlackList = {
  enabled: true;
  hostname: string;
  path: string;
  port: number;
  apiKey: string;
  errorPolicy: "AllowJoining" | "DenyJoining";
}

export type BlackList = EnabledBlackList | {
  enabled: false;
}

export interface RestApiResponse {
  name?: string;
  worldName?: string;
  terrariaServerPort?: number;
  hasServerPassword?: boolean;
  maxPlayers?: number;
  version?: string;
}

export interface RestApi {
  enabled: boolean;
  port: number;
  response?: RestApiResponse;
}

export interface ConnectionLimit {
  enabled: boolean;
  connectionLimitPerIP: number;
  kickReason: string;
}

export interface ConnectionRateLimit {
  enabled: boolean;
  connectionRateLimitPerIP: number;
}

export interface RedisConfig {
  enabled: boolean;
  host: string;
  port: number;
}

export interface NameChanges {
  mode: "legacy" | "rewrite";
  exclusions: string[];
}

export type UnvalidatedDebuffOnSwitch = {
  enabled: false;
} | {
  enabled: true;
  buffTypes?: number[];
  debuffTimeInSeconds?: number;
}

export type DebuffOnSwitch = {
  enabled: false;
} | {
  enabled: true;
  buffTypes: number[];
  debuffTimeInSeconds: number;
}

export type DisconnectOnKick = {
  type: "always";
} | {
  type: "never";
} | {
  type: "onKickReasonPrefix";
  kickReasonPrefixes: string[];
}

export interface UnvalidatedConfigOptions {
  socketTimeout: number;
  socketNoDelay: boolean;
  fakeVersion: FakeVersion;
  restApi: RestApi;
  blockInvis: boolean;
  blacklist: UnvalidatedBlackList;
  log: LogOptions;
  connectionLimit: ConnectionLimit;
  connectionRateLimit: ConnectionRateLimit;
  redis: RedisConfig;
  nameChanges?: NameChanges;
  language?: string;
  languageOverrides?: Language.LanguagePhrasesOverrides;
  debuffOnSwitch?: UnvalidatedDebuffOnSwitch;
  disconnectOnKick?: DisconnectOnKick;
}

export interface ConfigOptions {
  socketTimeout: number;
  socketNoDelay: boolean;
  fakeVersion: FakeVersion;
  restApi: RestApi;
  blockInvis: boolean | { enabled: boolean, servers: string[] };
  blacklist: BlackList;
  log: LogOptions;
  connectionLimit: ConnectionLimit;
  connectionRateLimit: ConnectionRateLimit;
  redis: RedisConfig;
  nameChanges?: NameChanges;
  language: Language.LanguageDefinition,
  debuffOnSwitch: DebuffOnSwitch;
  disconnectOnKick: DisconnectOnKick;
}

export interface UnvalidatedConfig {
  servers: (ConfigListenServer | ConfigNoListenServer)[];
  options: UnvalidatedConfigOptions;
}

export interface Config {
  servers: (ConfigListenServer | ConfigNoListenServer)[];
  options: ConfigOptions;
}

const unvalidatedConfig: UnvalidatedConfig = require(`../../../config.js`).ConfigSettings;
const debuffOnSwitch = { enabled: true, buffTypes: [ /* Webbed */ 149, /* Stoned */ 156], debuffTimeInSeconds: 5 }
const disconnectOnKick: DisconnectOnKick = { type: "never" };
const blacklist: BlackList = { enabled: false };
let validatedConfig: Config = {
  servers: unvalidatedConfig.servers,
  options: {
    ...unvalidatedConfig.options,
    blacklist,
    debuffOnSwitch,
    disconnectOnKick,
    language: Language.english,
  },
};

try {
  if (typeof unvalidatedConfig.options.nameChanges !== "undefined") {
    assert(unvalidatedConfig.options.nameChanges.mode === "legacy" || unvalidatedConfig.options.nameChanges.mode === "rewrite", "nameChanges.mode must be either 'legacy' or 'rewrite'");
    assert(Array.isArray(unvalidatedConfig.options.nameChanges.exclusions), "nameChanges.exclusions must be an array");
  }

  if (typeof unvalidatedConfig.options.debuffOnSwitch !== "undefined") {
    if (!unvalidatedConfig.options.debuffOnSwitch.enabled) {
      debuffOnSwitch.enabled = false;
    } else {
      if (typeof unvalidatedConfig.options.debuffOnSwitch.buffTypes !== "undefined") {
        debuffOnSwitch.buffTypes = unvalidatedConfig.options.debuffOnSwitch.buffTypes;
      }
      if (typeof unvalidatedConfig.options.debuffOnSwitch.debuffTimeInSeconds !== "undefined")
        debuffOnSwitch.debuffTimeInSeconds = unvalidatedConfig.options.debuffOnSwitch.debuffTimeInSeconds;
    }
  }

  if (typeof unvalidatedConfig.options.disconnectOnKick !== "undefined") {
    if (unvalidatedConfig.options.disconnectOnKick.type === "onKickReasonPrefix") {
      assert(Array.isArray(unvalidatedConfig.options.disconnectOnKick.kickReasonPrefixes), "disconnectOnKick.kickReasonPrefixes must be an array");
      validatedConfig.options.disconnectOnKick = {
        type: "onKickReasonPrefix",
        kickReasonPrefixes: unvalidatedConfig.options.disconnectOnKick.kickReasonPrefixes,
      }
    } else {
      unvalidatedConfig.options.disconnectOnKick.type = unvalidatedConfig.options.disconnectOnKick.type;
    }
  }

  if (typeof unvalidatedConfig.options.language !== "undefined") {
    switch (unvalidatedConfig.options.language.toLowerCase()) {
      case Language.english.isoCode.toLowerCase():
      case Language.english.name.toLowerCase():
      case Language.english.englishName.toLowerCase():
        break;
      case Language.chinese.isoCode.toLowerCase():
      case Language.chinese.name.toLowerCase():
      case Language.chinese.englishName.toLowerCase():
        validatedConfig.options.language = Language.chinese;
        break;
      default:
        console.log("Unrecognised language:", unvalidatedConfig.options.language);
        process.exit(1);
    }
  }

  if (typeof unvalidatedConfig.options.languageOverrides !== "undefined") {
    validatedConfig.options.language.phrases = {
      ...validatedConfig.options.language.phrases,
      ...unvalidatedConfig.options.languageOverrides,
    };
  }

  validatedConfig.options.blacklist.enabled = unvalidatedConfig.options.blacklist.enabled ?? false;
  if (validatedConfig.options.blacklist.enabled) {
    assert(typeof unvalidatedConfig.options.blacklist.hostname !== "undefined", "Blacklist enabled but no hostname provided");
    assert(typeof unvalidatedConfig.options.blacklist.path !== "undefined", "Blacklist enabled but no path provided");
    assert(typeof unvalidatedConfig.options.blacklist.port !== "undefined", "Blacklist enabled but no port provided");
    assert(typeof unvalidatedConfig.options.blacklist.apiKey !== "undefined", "Blacklist enabled but no api key provided");
    assert(unvalidatedConfig.options.blacklist.errorPolicy === "AllowJoining" || unvalidatedConfig.options.blacklist.errorPolicy === "DenyJoining", "Blacklist errorPolicy must be either 'AllowJoining' or 'DenyJoining'");

    validatedConfig.options.blacklist.hostname = unvalidatedConfig.options.blacklist.hostname!;
    validatedConfig.options.blacklist.path = unvalidatedConfig.options.blacklist.path!;
    validatedConfig.options.blacklist.port = unvalidatedConfig.options.blacklist.port!;
    validatedConfig.options.blacklist.apiKey = unvalidatedConfig.options.blacklist.apiKey!;
    validatedConfig.options.blacklist.errorPolicy = unvalidatedConfig.options.blacklist.errorPolicy!;
  }

} catch (e) {
  console.log("Error validating config:");
  throw e
}
export const ConfigSettings: Config = validatedConfig;
